{"meta":{"title":"花城","subtitle":"花城の博客","description":"本科 | 太原理工大学 | 信息安全","author":"花城","url":"https://huacheng1122.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.439Z","comments":true,"path":"404.html","permalink":"https://huacheng1122.cn/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.458Z","comments":true,"path":"List/index.html","permalink":"https://huacheng1122.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-09-26T04:36:41.896Z","updated":"2021-09-26T04:36:41.896Z","comments":true,"path":"baidu_verify_code-m7XmXYVUbo.html","permalink":"https://huacheng1122.cn/baidu_verify_code-m7XmXYVUbo.html","excerpt":"","text":"aed9da353918032f2fbb28bf2b3a4a22"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.619Z","comments":true,"path":"about/index.html","permalink":"https://huacheng1122.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"archives/index.html","permalink":"https://huacheng1122.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"categories/index.html","permalink":"https://huacheng1122.cn/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"census/index.html","permalink":"https://huacheng1122.cn/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"friends/index.html","permalink":"https://huacheng1122.cn/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-26T12:50:56.301Z","comments":true,"path":"contact/index.html","permalink":"https://huacheng1122.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 花城の友链信息 博客名称: 花城の博客 博客网址: https://huacheng1122.cn 博客头像: https://bucket-1305778438.cos.ap-shanghai.myqcloud.com/myblog/logo2.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.637Z","comments":true,"path":"tags/index.html","permalink":"https://huacheng1122.cn/tags/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.635Z","comments":true,"path":"resource/index.html","permalink":"https://huacheng1122.cn/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-25T17:04:00.468Z","updated":"2021-09-25T01:03:03.449Z","comments":true,"path":"List/galleries/index.html","permalink":"https://huacheng1122.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/movies/index.html","permalink":"https://huacheng1122.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/music/index.html","permalink":"https://huacheng1122.cn/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/tools/index.html","permalink":"https://huacheng1122.cn/List/tools/index.html","excerpt":"","text":""},{"title":"宇航员和月亮的故事","date":"2021-09-25T16:44:08.387Z","updated":"2021-09-25T16:43:44.141Z","comments":true,"path":"List/galleries/宇航员和月亮的故事/index.html","permalink":"https://huacheng1122.cn/List/galleries/%E5%AE%87%E8%88%AA%E5%91%98%E5%92%8C%E6%9C%88%E4%BA%AE%E7%9A%84%E6%95%85%E4%BA%8B/index.html","excerpt":"","text":""}],"posts":[{"title":"排兵布阵问题","slug":"排兵布阵问题","date":"2021-09-29T10:24:10.000Z","updated":"2021-09-29T10:38:13.531Z","comments":true,"path":"posts/7f393998.html","link":"","permalink":"https://huacheng1122.cn/posts/7f393998.html","excerpt":"","text":"0x001 问题描述 某游戏中，不同的兵种处于不同的地形上时，其攻击能力也一样，现有n个不同兵种的角色$(1, 2, \\cdots, n)$，需安排在某战区$n$个点上，角色$i$在$j$点上的攻击力为$A_{ij}$，试设计一个布阵方案，使总的攻击力最大。注：个人决定A矩阵的初始化工作。 0x002 目标函数 \\max \\{ \\sum_{i=1}^n power_i\\}0x003 解向量 用元组$(x_1,x_2,…x_n)$表示解，$x_i$表示角色i的位置。 0x004 显式约束 S_i=\\{1,2,...,n\\},1\\leq i \\leq n0x005 状态空间树 类型状态空间树是一颗排列树。 候选解规模叶子结点数有$n!$个。 0x006 隐式约束 对任意$1 \\leq i,j \\leq n$,当$i \\neq j$时，$x_i \\neq x_j$ 0x007 算法设计 算法的伪代码描述function backTrack(t, n) if t &gt; n then power ← 0 for i = 1 → n do power ← power + power1 if power &lt; powermax then powermax ← power x1 ← x else for i = 1 → n do x[t] ← i if Position(t) then backTrack(t + 1) end function function Position(k) for i = 1 → k − 1 do if x[i] == x[k] then return false return true end function 时间复杂度估计W(n) = p(n)f(n)$p(n)$为求解一个叶子节点的时间，$f(n)$为叶子节点的个数 编码实现#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt; x,x1; vector&lt;vector&lt;int&gt; &gt; p; int powermax = -1; int n; //判断角色k的位置是否可行 bool position(int k){ for(int i = 1;i &lt; k;i ++){ if(x[k] == x[i]){ return false; } } return true; } //回溯法求最优解 void backTrack(int t){ if(t &gt; n){//求总攻击力并更新最大值 int power = 0; for(int i = 1;i &lt;= n;i ++){ power = power + p[i][x[i]]; } if(power &gt; powermax){ powermax = power; x1 = x;//记录当前最优解的排列 } }else{//遍历可行排列 for(int i = 1;i &lt;= n;i ++){ x[t] = i; if(position(t)){ backTrack(t+1); } } } } int main(){ cin &gt;&gt; n; for(int i = 0;i &lt;= n;i ++){ x.push_back(0); x1.push_back(0); } for(int i = 0;i &lt;= n;i ++){ p.push_back(x); } for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ int p1; cin &gt;&gt; p1; p[i][j] = p1; } } backTrack(1); cout &lt;&lt; \"最优解为：\" &lt;&lt; endl; for(int i = 1;i &lt;= n;i ++){ cout &lt;&lt; x1[i] &lt;&lt; \" \"; } cout &lt;&lt; \"最大攻击力为：\" &lt;&lt; powermax &lt;&lt; endl; return 0; } 程序调试与结果展示 0x008 结束语 别让怯懦否定了自己，别让懒惰耽误了青春","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"最优二叉搜索树问题","slug":"最优二叉搜索树问题","date":"2021-09-29T09:52:31.000Z","updated":"2021-09-29T10:04:15.810Z","comments":true,"path":"posts/a294f3d3.html","link":"","permalink":"https://huacheng1122.cn/posts/a294f3d3.html","excerpt":"","text":"0x001 问题描述 给定递增有序的元素序列$S=\\left \\langle a_1,a_2,\\cdots,a_n\\right \\rangle$与相关存取概率分布$C=\\left \\langle q(0), p(1), q(1), p(2), q(2), \\cdots, p(n), q(n) \\right \\rangle$，将这些元素存储在一棵二叉树的结点上，以查找$x$是否在这些数中。如果$x$不在，确定$x$在哪个空隙。设法构造一棵最优二叉搜索树使得平均查找次数$t$最小。一棵二叉搜索树的平均查找次数定义如下： t=\\sum_{i=1}^{n}{p(i)(1+d(i))}+\\sum_{j=0}^{n}{q(j)d(j)}其中，$d(i)$表示结点$ai$的深度，$i=1,2,\\cdots, n$；$d(j)$表示空隙(叶子)结点$(a_j, a{j+1})$的深度，$j=0,1,\\cdots, n$。 0x002 问题建模 1.子问题的边界参数化$S[i,j]=$是$S$ 以$i$和$j$作为边界的子数据集，$C[i，j]=$是对应$S[i,j]$存取概率分布。子问题划分：以$x_k$作为根划分成两个子问题 S[i,k-1],C[i，k-1]S[k+1,j],C[k+1，j]2.递推关系 设m[i,j]是相对于输入S[i,j]和C[i，j]的最优二叉搜索树的平均比较次数，令w[i,j]=\\sum_{p=i-1}^ja_p+\\sum_{q=i}^jb_q是C[i，j]中所有概率（包括数据元素与空隙）之和，则递推方程为 \\begin{cases} m[i,j]=\\min \\{m[i,k-1]+m[k+1,j]+w[i,j]\\} &\\text{if } 1\\leq i\\leq j \\leq n \\\\ m[i,i-1]=0 &\\text{if } i=1,2,...n \\end{cases}3.备忘录表与标记函数表 w:最优二叉搜索树的权; m:计算最优二叉搜索树的成本; r:最优二叉搜索树的根。 0x003 算法的复杂度分析 $i,j$的所有组合$O(n^2)$种，每种要对不同的k进行计算，$k=O(n)$每次计算为常数时间 T(n)=O(n^3),S(n)=O(n^2)0x004 算法的迭代实现伪代码描述 tidyfunction BST(p, q, n) let m[1...n+1,0...n],w[1...n+1,0...n] and r[1...n,1...n] be new tables for i = 1 → n + 1 do m[i, i − 1] ← 0 w[i, i − 1] ← qi−1 for l = 1 → n do for i = 1 → n − l + 1 do j ← i + l − 1 m[i, j] ← ∞ w[i, j] ← w[i, j − 1] + pj + qj for r = i → j do t ← m[i, r − 1] + m[r + 1, j] + w[i, j] if t &lt; m[i, j] then m[i, j] ← t r[i, j] ← r return m, r end function 0x005 迭代实现的源代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; S,C; vector&lt;vector&lt;int&gt; &gt; w,m,r;//定义备忘录表 vector&lt;int&gt; B; for(int i = 1;i &lt;= n;i ++){ int a; cin &gt;&gt; a; S.push_back(a); }//输入集合S for(int i = 0;i &lt; 2*n+1;i ++){ double a; cin &gt;&gt; a; C.push_back(100*a); }//输入存取概率，乘以100 for(int j = 0;j &lt;= n+1;j++){ B.push_back(0); } for(int i = 0;i &lt;= n+1;i++){ m.push_back(B); w.push_back(B); r.push_back(B); } for(int i = 1;i &lt;= n+1;i ++){ m[i][i-1] = 0; w[i][i-1] = C[2*(i-1)]; }//初始化备忘录表 for(int l = 1;l &lt;= n;l ++){ for(int i = 1;i &lt;= n-l+1;i ++){ int j = i+l-1; m[i][j] = 2147483647; w[i][j] = w[i][j-1] + C[2*j-1] + C[2*j]; for(int root = i;root &lt;= j;root ++){ int t = m[i][root-1] + m[root+1][j] + w[i][j]; if(t &lt; m[i][j]){ m[i][j] = t; r[i][j] = root; } } } }//利用备忘录法迭代实现构造最优二叉搜索树 for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ cout &lt;&lt; r[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; }//输出记录根节点的表 cout &lt;&lt; \"最小代价为\" &lt;&lt; (double)m[1][n]/100; return 0;//输出最小期望代价 } 0x006 运行结果截图 0x007 结束语 没有明确表达的爱意都是错觉","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"MonteCarlo方法","slug":"MonteCarlo方法","date":"2021-09-29T09:40:47.000Z","updated":"2021-09-29T09:46:56.655Z","comments":true,"path":"posts/1960c1bd.html","link":"","permalink":"https://huacheng1122.cn/posts/1960c1bd.html","excerpt":"","text":"0x001 估计四皇后搜索树的结点数 case1：&lt;1,4,2&gt;第一行选择放在第一列（四选一），之后第二行可以放在第三、四列（二选一），第二行选择放在第四列，之后第三行只能放在第二列（一选一），第四行无法放。（搜索树中每条边代表一个选择）$1+4+4\\times 2+4\\times 2=21$ case2：&lt;2,4,1,3&gt;第一行放在第二列（四选一）之后，其他三列位置固定（全是一选一）$4\\times 4 +1=17$ case3：&lt;1,3&gt;$1+4\\times 1+4\\times 2=13$ 0x002 结束语 我有一瓢酒，可以慰风尘","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"author":"花城"},{"title":"动态规划_每对结点间的最短路径_Floyd","slug":"动态规划-每对结点间的最短路径-Floyd","date":"2021-09-29T08:50:34.000Z","updated":"2021-09-29T09:15:33.774Z","comments":true,"path":"posts/9584e53f.html","link":"","permalink":"https://huacheng1122.cn/posts/9584e53f.html","excerpt":"","text":"0x001 问题描述 设$G=(V,E)$是一个有$n$个结点的带权有向图，$w(i,j)$是权函数 w(i,j)=\\begin{cases} 边上的权值 &\\text{if } \\in E \\\\ 0 &\\text{if } i=j\\\\ \\infty &\\text{if } \\notin E \\end{cases}每对结点间的最短路径问题是指图中任意一对结点$i$和$j$之间的最短路径。 0x002 分析 Dijkstra算法要求图中的边的权为非负值，而本问题中允许边的权为负值，但不允许路径长度为负值的回路，因为若结点$i$到结点$j$的路径上存在负值回路，则意味着结点$i$到结点$j$没有最短路径。 0x003 最优子结构特性 设$G=(V,E)$是带权有向图，L(i,j)是从结点$i$到结点$j$的最短路径长度，$k$是这条路径上的一个结点，$L(i,k)$和$L(k,j)$分别是从$i$到$k$和从$k$到$j$的最短路径长度，则必有$L(i,j)=L(i,k)+L(k,j)$,若不然，则$L(i,j)$代表的路径就不是最短路径。 0x004 最优解值的递推关系 d_{-1}[i][j]=\\begin{cases} w(i,j) &\\text{if } \\in E \\\\ \\infty &\\text{if } \\notin E \\end{cases}d_k[i][j]=\\min\\{d_{k-1}[i][j],d_{k-1}[i][k]+d_{k-1}[k][j]\\},1\\leq k \\leq n-1其中$dk[i][j]$表示从结点$i$到结点$j$的路径上，只允许包含编号不大于$k$的结点时，所以可能的路径中的最短路径的长度，$d{-1}[i][j]$表示从$i$到$j$不包含结点（直达）的长度，$L(i,j)=d_{n-1}[i][j]$ 0x005 重叠子问题 为了计算$dk[i][j]$时，必须计算$d{k-1}[i][j],d{k-1}[i][k],d{k-1}[k][j]$ 邻接矩阵$a$存储有向图 二维数组$d$用于保存各条最短路径的长度，其中$d[i][j]$存放从结点$i$到结点$j$的最短路径的长度 二维数组$path$记录相应的最短路径，$path[i][j]$给出从结点$i$到结点$j$的最短路径中的前一个结点，可以反向追溯最短路径 初始时$d[i][j]=a[i][j]$ 令$k=0,1,…,n-1$,每次考察一个结点$k$ 在算法的第$k$步上应作出决策：从$i$到$j$的最短路径上是否包含结点$k$ 0x006 程序 #include&lt;iostream&gt; using namespace std; vector&lt;vector&lt;int&gt; &gt; a;//邻接矩阵 vector&lt;vector&lt;int&gt; &gt; d;//保存每对结点之间最短路径 vector&lt;vector&lt;int&gt; &gt; path;//标记函数 int n;//结点数 //创建邻接矩阵 void CreateA(){ cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++){ vector&lt;int&gt; v; int v1; for(int j = 0;j &lt; n;j ++){ cin &gt;&gt; v1; v.push_back(v1); } a.push_back(v); } } void allPath(){ for(int i = 0;i &lt; n;i ++){//初始化d for(int j = 0;j &lt; n;j ++){ d[i][j] = a[i][j]; } } //迭代：对于点k，若i直接到j的距离大于1-&gt;k-&gt;j的距离和时，改写d[i][j] for(int k = 0;k &lt; n;k ++){ for(int i = 0;i &lt; n;i ++){ for(int j = 0;j &lt; n;j ++){ if(d[i][k]+d[k][j]&lt;d[i][j]) d[i][j] = d[i][k] + d[k][j]; } } } } int main(){ CreateA(); allPath(); return 0; } 0x007 结束语 其实你并没有什么忘不掉的人，只是始终对自己那场没有结果的付出和被浪费的爱耿耿于怀。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"动态规划_备忘录法_矩阵链乘","slug":"动态规划-备忘录法-矩阵链乘","date":"2021-09-29T03:50:39.000Z","updated":"2021-09-29T04:45:33.256Z","comments":true,"path":"posts/46b98235.html","link":"","permalink":"https://huacheng1122.cn/posts/46b98235.html","excerpt":"","text":"0x001 问题描述 给定$n$个矩阵${A1,A_2,A_3,…,A_n}$，其中$A_i$为$P{i-1} Pi$矩阵，$i = 1,…,n$，并且$A_i$与$A{i-1}$是可乘的。由于矩阵乘法满足结合律，所以计算矩阵的链乘可有许多不同的计算次序，两个矩阵$A_{ij}$与$A_{j k}$相乘的工作量为i j * k次数乘。 给定向量$P= (P_0,P_1,…,P_n)$为$n$个矩阵的行数和列数，确定一种乘法次序，使得基本运算“数乘”的总次数最少。 0x002 完全加括号 完全加括号的矩阵链乘积可递归地定义为： 单个矩阵是完全加括号的 矩阵链乘积$A$是完全加括号的，则$A$可表示为两个完全加括号的矩阵链乘积$B$和$C$的乘积，并加括号，即$A=(BC)$ 0x003 最优子结构 矩阵链乘$AiA{i+1}…Aj$简记为$A{i…j},i&lt; j$，于是矩阵链乘$A1A_2…A_n$可记为$A{1…n}$，完全加括号形式为 A_{1...n}=A_{1...k}A_{k+1...n},1< k < n 矩阵连乘$A{1…n}$的最优计算次序的计算量等于$A{1…k}$和$A{k+1…n}$两者的最优计算次序的计算量之和，再加上$A{1…k}$和$A_{k+1…n}$相乘的计算量。矩阵链乘问题的最优解具有最优子结构特性。 0x004 最优解的递推关系 由$i$和$j$确定子问题的边界，输入$P=(P_0,P_1,…P_n)$ A_{i...j}=A_{i...k}A_{k+1...j},k=i,i+1,...,j-1 确定优化函数和递推方程：二维数组$m$用来保存矩阵链乘时所需的最小计算量 m[i][j]=\\begin{cases} \\min\\limits_{i\\leq k < j} \\{m[i][k]+m[k+1][j]+P_{i-1}P_kP_j\\} &\\text{if } i","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"分治算法_主元素问题","slug":"分治算法-主元素问题","date":"2021-09-28T16:16:52.000Z","updated":"2021-09-29T04:10:16.084Z","comments":true,"path":"posts/d7a49e9b.html","link":"","permalink":"https://huacheng1122.cn/posts/d7a49e9b.html","excerpt":"","text":"0x001 问题描述 设$T[0:n-1]$是$n$个元素的数组，对任一元素$x$，设$s(x)={i|T[i]=x}$,当$|s(x)|&gt;n/2$时，称$x$为$T$的主元素，设计一个线性时间算法，确定$T[0:n-1]$是否有一个主元素。 0x002 分析 若$T$存在主元素则将$T$分为两部分，$T$的主元素也必为两部分中至少一部分的主元素，将元素划分两部分，递归检查两部分有无主元素。 若$T$只含一元素，则此元素就是主元素，返回此数$T_1,T_2$主元素$m_1,m_2$ 若$m_1=m_2$且$m_1\\ne null$,返回此数 若$m_1\\ne null$,if $m_1$为主元素，返回$m_1$ 若$m_2\\ne null$,if $m_2$为主元素，返回$m_2$ 否则返回$null$ 0x003 算法 是否为主元素bool isMaster(int m){ int k = 0; for(int i = 0;i &lt; n;i ++){ if(T[i] = m) k++; } if(k &gt; n/2) return true; else return false; } 寻找主元素int findMaster(vector&lt;int&gt; T,int n){ if(n == 1){ return T[1]; }else{ vector&lt;int&gt; T1,T2; for(int i = 0;i &lt;= n/2;i ++){ T1.push_back(T[i]); } for(int i = n/2+1;i &lt; n;i ++){ T2.push_back(T[i]); } m1 = findMaster(T1,n/2+1); m2 = findMaster(T2,n/2-1); if(m1 == m2 &amp;&amp; m1 != m2) return m1; if(m1 != Null){ if(isMaster(m1)) return m1; } if(m2 != Null){ if(isMaster(m2)) return m2; } return Null; } } 主函数#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main(){ int n,master; cin &gt;&gt; n; vector&lt;int&gt; T; for(int i = 0;i &lt; n;i ++){ int t; cin &gt;&gt; t; T.push_back(t); } master = findMaster(T,n); cout &lt;&lt; \"主元素：\" &lt;&lt; master; return 0; } 0x004 结束语 山林不向四季起誓，荣枯随缘","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"动态规划_多段图问题","slug":"动态规划-多段图问题","date":"2021-09-27T15:12:48.000Z","updated":"2021-09-27T16:49:22.875Z","comments":true,"path":"posts/6850d53f.html","link":"","permalink":"https://huacheng1122.cn/posts/6850d53f.html","excerpt":"","text":"0x001 问题描述 将$n$个资源分配给$r$个项目，已知如果把$j$个资源分配给第$i$个项目，可以收益$N(i,j),0 \\leq j \\leq n,1 \\leq i \\leq r$,求总收益最大的资源分配方案。 0x002 问题分析 1.用$r+1$段图描述 2.每个状态节点$V(i,j)$代表已将$j$个资源分配给前$i-1$个项目 3.边都具有$(V(i,j),V(i+1,k))(0 \\leq j \\leq k \\leq n,1 \\leq i \\leq r)$ 4.边上的权值$N(i,k-j)$是本次分配的收益 5.$r+1$个阶段 第一个阶段：开始阶段尚未分配任何资源，只包含一个初始状态$S=V(1，0)$ 第$r+1$阶段：结束阶段，表示整个分配完成，只有一个结束状态$t=V(r+1,n)$ 其他$r-1$个中间阶段：每个阶段包含$n+1$个状态 0x003 多段图概述 设图 $G =(V,E)$是一个带权有向图，如果把顶点集合 $V$ 划分成$k$个互不相交的子集 $V_i(2\\leq k\\leq n,1\\leq i\\leq k)$，使得$E$ 中的任何一条边 $$，必有 $u∈Vi, v∈Vi + m(1\\leq i &lt; k, 1&lt;i+m\\leq k)$,则称图 $G$ 为多段图，称 $s∈V_1$ 为源点，$t∈V_k$ 为终点。多段图的最短路径问题为从源点到终点的最小代价路径。 0x004 递推关系 （从后）向前递推关系式 \\begin{cases} cost(i,j)= \\min\\limits_{j∈V_i,p∈V_{i+1},∈E} \\{c(j,p)+cost(i+1,p)\\} &\\text{if } 0\\leq i \\leq k-2 \\\\ cost(k,t)=0 \\end{cases}$cost(i,j)$是从第$i$阶段中某个节点状态$j$到汇点状态$t$的最短路径长度，$cost(1,0)$为多段图问题的最优解值，即为所求。 设$d(i,j)$表示从第$i$阶段节点$j$到$t$的最短路径上节点$j$的下一个节点编号，利用$d$值进行反向追溯可确定最短路径上的节点。 0x005 程序设计 数据结构：采用邻接表存储该有向无环图的节点及边的信息 源点$s$编号为0，汇点的编号为$n-1$（共有$n$节点，$m$条边） $cost[i]$保存节点$i$到汇点$t$的最短路径长度 $cost[n-1]$为0，汇点到汇点的最短路径长度为0 $cost[0]$为最优解值，为计算$cost[j]$,必须计算子问题：后继节点$p$到汇点的最短路径$cost[p]$ $cost[j]=\\min{c(j,p)+cost[p]}$,$c(j,p)$为边$$的长度（权） 代码 节点结构 Struct ENode{ int adjVex; int w; ENode *nextArc } 其他变量 vector&lt;Struct ENode&gt; a;//邻接表，数组中存节点 vector&lt;int&gt; cost;//最短长度 int n;//总节点数 int m;//总边数 构建邻接表 void CreatGraph(){ int u,v; int w; Struct ENode t; for(int i = 0;i &lt; n;i ++){ a.push_back(t); } for(int i = 0;i &lt; m;i ++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t-&gt;adjVex = v; t-&gt;nextArc = a[u]; t-&gt;w = w; a[u] = t; } } 向前递推算法 void FMultiGraph(){ cost[n-1] = 0; int min; Struct ENode r; for(int i = n-2;i &gt;= 0;i --){ min = max; for(Struct ENode r = a[i];r;r = r-&gt;nextArc){ if(r-&gt;w + cost[r-&gt;adjVex] &lt; min){ min = r-&gt;w + cost[r-&gt;adjVex]; } } cost[i] = min; } } 0x006 结束语 旅人等在这里，虔诚仰望着云开","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"记一次博客搭建感受","slug":"huacheng-blog","date":"2021-09-27T13:17:55.000Z","updated":"2021-09-29T04:09:17.822Z","comments":true,"path":"posts/a63d1ca2.html","link":"","permalink":"https://huacheng1122.cn/posts/a63d1ca2.html","excerpt":"","text":"0x001 博客效果图 博客地址：https://huacheng1122.cn 今天博客基本搭建完成，连着折腾了五六天，弱弱的身体表示很虚。后续还会继续完善和更新博客。 最开始博客我用的是博客园和CSDN的，直到一个礼拜前在网上看到了大佬Luckysec的一篇博客,才注意到他的博客，真是让我眼前一亮，两眼放光，目瞪口呆~~ 于是我搭建了他的开源博客。现在主要用自己搭建的博客和CSDN，不是说博客园不好，而是我更喜欢搭建的博客的这种自由之风。 博客基本和博主的差不多，有些封面没有好看的图片，暂时用博主的，之后还会换。 大神的博客：http://www.luckyzmj.cn/ 基于hexo框架和github部署 在整个搭建过程中，原以为很简单，不料~┭┮﹏┭┮，部署到github出现错误（由于配置不当和nodejs版本低）；购买域名后再次配置和部署出现错误；还有一些网站收录；等一系列问题，由于没有记录，无法详细说明，这些问题着实让人烦恼，但在查找问题的时候，不自觉的也学到了很多知识，自己还是很满足的，之后会继续学习，努力向大神看齐！ 再次欢迎大家关注博客，互相学习交流嘛~ https://huacheng1122.cn 0x002 结束语 看不清未来时，就比别人坚持久一点。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://huacheng1122.cn/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"花城"},{"title":"Hello World","slug":"hello-world","date":"2021-09-24T17:41:33.373Z","updated":"2021-09-25T01:07:30.716Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://huacheng1122.cn/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"},{"name":"博客","slug":"博客","permalink":"https://huacheng1122.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}